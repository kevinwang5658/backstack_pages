{
    "docs": [
        {
            "location": "/", 
            "text": "BackStack\n\n\nBackStack is a light weight back stack library for view based navigation on Android. Using BackStack provides an easy way to switch between view groups without having to worry about back navigation. A navigation tree built by BackStack will also be persisted through rotation and activity restarts. BackStack works with linear navigation flows as well as split flows like bottom bars and view pagers.\n\n\nPhilosophy\n\n\nHistory\n\n\nThe navigation style that BackStack uses is view group based navigation. This means that instead of using Activities and Fragments to provide different screens, a light-weight ViewGroup is used instead. Over the years, there have been many discussions on this subject. If you want to go through it, a summary of the history can be found \nhere\n.\n\n\nGoogle officially recommends the use of fragments. However, people in the android community, myself included, find that fragments are large bloated objects that obscures a lot it's functionality behind layers of code. There have also been problem reported weird memory leaks and problems with the asynchronous nature of fragment transactions. The consensus in the community is that people generally don't like using fragments.\n\n\nIn 2014 square began a movement,  \nhere\n, to use view groups in place of fragments. They argued that view groups are light weight containers that adhere to the Android lifecycle, something that seems perfect to use as a container for a screen. View groups, however have their own limitations. Mainly that, they don't inherently come back navigation and persistence through rotations. This is where BackStack comes in.\n\n\nBackStack\n\n\nBackStack is view group based back navigation library. It aims to overcome the limitations of view groups and make them a viable choice for use in-place of fragments or activities. BackStack is built around the concept of a view creator, a contextless object that does what it's name says, creates views. Each view creator is associated with a particular view group. View creators don't hold state about what they create or who told them to create what. By doing this, each view group can be inflated independent of each other regardless of the order or conditions they were first created in. BackStack stores a stack of view creators in chronological order. The view creator at the top of the stack will inflate the view that is actually shown to the user. Using this stack, BackStack can return to any previous views. View creators are contextless, and therefore they can also be persisted through activity restarts without leaking.\n\n\nUsing BackStack\n\n\npublic static class MyViewCreator implements ViewCreator{\n    @Override\n    public ViewGroup create(LayoutInflater layoutInflater, ViewGroup container) {\n        CustomViewGroup vg = new CustomViewGroup(layoutInflater.getContext());\n        container.addView(vg);\n        return vg;\n    }\n}\n...\n\npublic void foo(){\n    linearBackStack.add(new MyViewCreator());\n}\n\n\n\n\nView creators are very simple to make. They are simply classes that implement the ViewCreator interface. All view creators must adhere to 2 rules. First, by the end of the create function the inflated view group must be added to the parent container, sort of like in a ListView . Secondly, the class must not capture any references to the Android context. This means that only regular classes, static inner classes and lambdas that don't explicitly capture are eligible to be view creators; anonymous inner classes can't be used because they implicitly capture. This is done so that the view creator doesn't leak when it's persisted.\n\n\nlinearBackStack.add((layoutInflater, container) -\n {\n     CustomViewGroup vg = new CustomViewGroup(layoutInflater.getContext());\n     container.addView(vg);\n     return vg;\n });\n\n\n\n\nWhen using this library, it is highly recommended that you \nenable Java 8 language features\n. This allows you to use lambdas which greatly simplifies the code and improves the readability.\n\n\nFor more information please visit the \ndocumentation\n.\n\n\nGetting BackStack\n\n\nUsing Gradle:\n\n\nbuild.gradle (Project)\n\n\nallprojects {\n    repositories {\n        jcenter()\n        maven{\n            url 'https://jitpack.io'\n        }\n    }\n}\n\n\n\n\nbuild.gradle (Module)\n\n\ndependencies {\n    compile 'com.github.kevinwang5658:backstack:v2.3'\n}", 
            "title": "Home"
        }, 
        {
            "location": "/#backstack", 
            "text": "BackStack is a light weight back stack library for view based navigation on Android. Using BackStack provides an easy way to switch between view groups without having to worry about back navigation. A navigation tree built by BackStack will also be persisted through rotation and activity restarts. BackStack works with linear navigation flows as well as split flows like bottom bars and view pagers.", 
            "title": "BackStack"
        }, 
        {
            "location": "/#philosophy", 
            "text": "", 
            "title": "Philosophy"
        }, 
        {
            "location": "/#history", 
            "text": "The navigation style that BackStack uses is view group based navigation. This means that instead of using Activities and Fragments to provide different screens, a light-weight ViewGroup is used instead. Over the years, there have been many discussions on this subject. If you want to go through it, a summary of the history can be found  here .  Google officially recommends the use of fragments. However, people in the android community, myself included, find that fragments are large bloated objects that obscures a lot it's functionality behind layers of code. There have also been problem reported weird memory leaks and problems with the asynchronous nature of fragment transactions. The consensus in the community is that people generally don't like using fragments.  In 2014 square began a movement,   here , to use view groups in place of fragments. They argued that view groups are light weight containers that adhere to the Android lifecycle, something that seems perfect to use as a container for a screen. View groups, however have their own limitations. Mainly that, they don't inherently come back navigation and persistence through rotations. This is where BackStack comes in.", 
            "title": "History"
        }, 
        {
            "location": "/#backstack_1", 
            "text": "BackStack is view group based back navigation library. It aims to overcome the limitations of view groups and make them a viable choice for use in-place of fragments or activities. BackStack is built around the concept of a view creator, a contextless object that does what it's name says, creates views. Each view creator is associated with a particular view group. View creators don't hold state about what they create or who told them to create what. By doing this, each view group can be inflated independent of each other regardless of the order or conditions they were first created in. BackStack stores a stack of view creators in chronological order. The view creator at the top of the stack will inflate the view that is actually shown to the user. Using this stack, BackStack can return to any previous views. View creators are contextless, and therefore they can also be persisted through activity restarts without leaking.", 
            "title": "BackStack"
        }, 
        {
            "location": "/#using-backstack", 
            "text": "public static class MyViewCreator implements ViewCreator{\n    @Override\n    public ViewGroup create(LayoutInflater layoutInflater, ViewGroup container) {\n        CustomViewGroup vg = new CustomViewGroup(layoutInflater.getContext());\n        container.addView(vg);\n        return vg;\n    }\n}\n...\n\npublic void foo(){\n    linearBackStack.add(new MyViewCreator());\n}  View creators are very simple to make. They are simply classes that implement the ViewCreator interface. All view creators must adhere to 2 rules. First, by the end of the create function the inflated view group must be added to the parent container, sort of like in a ListView . Secondly, the class must not capture any references to the Android context. This means that only regular classes, static inner classes and lambdas that don't explicitly capture are eligible to be view creators; anonymous inner classes can't be used because they implicitly capture. This is done so that the view creator doesn't leak when it's persisted.  linearBackStack.add((layoutInflater, container) -  {\n     CustomViewGroup vg = new CustomViewGroup(layoutInflater.getContext());\n     container.addView(vg);\n     return vg;\n });  When using this library, it is highly recommended that you  enable Java 8 language features . This allows you to use lambdas which greatly simplifies the code and improves the readability.  For more information please visit the  documentation .", 
            "title": "Using BackStack"
        }, 
        {
            "location": "/#getting-backstack", 
            "text": "Using Gradle:  build.gradle (Project)  allprojects {\n    repositories {\n        jcenter()\n        maven{\n            url 'https://jitpack.io'\n        }\n    }\n}  build.gradle (Module)  dependencies {\n    compile 'com.github.kevinwang5658:backstack:v2.3'\n}", 
            "title": "Getting BackStack"
        }, 
        {
            "location": "/getting_started/", 
            "text": "Getting Started\n\n\nAdding BackStack\n\n\nUsing gradle:\n\n\nbuild.gradle (Project)\n\n\nallprojects{\n    repositories{\n        jcenter()\n        maven{\n            url 'https://jitpack.io'\n        }\n    }\n}\n\n\n\n\nbuild.gradle (Module)\n\n\ndependencies{\n    compile 'com.github.kevinwang5658:backstack:v2.3'\n}\n\n\n\n\nInitialization\n\n\nTo initialize BackStack simply add the following code in onCreate().\n\n\npublic class MainActivity extends AppCompatActivity {\n\n    BackStackManager backStackManager;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        ...\n\n        BackStack.install(this);\n        backStackManager = BackStack.getBackStackManager();\n    }\n\n    @Override\n    public void onBackPressed() {\n        if (!backStackManager.goBack()) {\n            super.onBackPressed();\n        }\n    }\n}\n\n\n\n\nCreating a Simple Back Stack\n\n\nTo begin we're going to focus on getting a linear back stack up and running. Linear back stacks are the main back stacks of this library. They are responsible for linear navigation flow \nscreenA -\n screenB -\n screenC\n. Linear back stacks will automatically implement back navigation and view hierarchy persistence.\n\n\nLet's start shall we?\n\n\npublic static final String TAG = \nTAG\n;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    BackStack.install(this);\n    backStackManager = BackStack.getBackStackManager();\n\n    //This is the container you want to be the root of your back stack\n    root = findViewById(R.id.root);\n\n    LinearBackStack linearBackStack = backStackManager.createLinearBackStack(\nTAG\n, root, (layoutInflater, container) -\n {\n        //This is our first view group in the stack\n        CustomViewGroup cvg = new CustomViewGroup(layoutInflater.getContext());\n\n        //Make sure that the view is added to container by the end of this block\n        container.addView(cvg);\n\n        //Return the view group that was newly inflated\n        return cvg;\n    });\n}\n\n\n\n\nLet's make a view group called CustomViewGroup.\n\n\npublic class CustomViewGroup extends RelativeLayout{\n    public CustomViewGroup(Context context) {\n        super(context);\n\n        //Let's set the background color so that we know\n        //that the view group has been added\n        setBackgroundColor(Color.GRAY);\n\n        //Let's inflate an xml file with the children of this view group\n        LayoutInflater.from(context).inflate(R.layout.custom_view_group, this, true);\n    }\n}\n\n\n\n\nAnd that's it. If you run this, you should see a gray screen instead of the default white. The first view group has been added to your stack.\n\n\nAdding Subsequent View Groups\n\n\nNow let's say that this gray screen is the home of our app, and that when we click on something we want to change to the next screen. Let's simulate this by setting an onClick listener on the entire screen.\n\n\npublic class CustomViewGroup extends RelativeLayout{\n    public CustomViewGroup(Context context) {\n        super(context);\n\n        //Let's set the background color so that we know\n        //that the view group has been added\n        setBackgroundColor(Color.GRAY);\n\n        //Let's inflate an xml file with the children of this view group\n        LayoutInflater.from(context).inflate(R.layout.custom_view_group, this, true);\n\n        setOnClickListener(v -\n {\n\n        });\n\n    }\n}\n\n\n\n\nThis time let's inflate the view through xml as well just to change things up. So let's first create an xml layout file called added_view.xml\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\ncom.rievo.test.AddedViewGroup xmlns:android=\nhttp://schemas.android.com/apk/res/android\n\n    android:layout_width=\nmatch_parent\n\n    android:layout_height=\nmatch_parent\n\n    android:background=\n@android:color/white\n\n    \n!-- Let's set the background color to white so that we can see a change--\n\n\n/com.rievo.test.AddedViewGroup\n\n\n\n\n\nLet's change our on click listener\n\n\nsetOnClickListener(v -\n {\n    //All back stacks can be retrieved anywhere using their tag\n    LinearBackStack linearBackStack = (LinearBackStack) BackStack.getStack(MainActivity.TAG);\n    linearBackStack.add((layoutInflater, container) -\n {\n        //if attach to root is true layoutInflater.inflate() returns the container instead\n        ViewGroup viewGroup = (ViewGroup) layoutInflater\n                .inflate(R.layout.added_view, container, false);\n        container.addView(viewGroup);\n        return viewGroup;\n    });\n});\n\n\n\n\nNow let's try it. Clicking on the screen should change the screen color to white. Let's say this represents an info page or something. If you rotate your device you'll see that the screen remains white, this means that navigation stack was persisted. Pressing back should lead you back to the home screen. For more advanced usage of this library please proceed to the \nnext section\n.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting_started/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting_started/#adding-backstack", 
            "text": "Using gradle:  build.gradle (Project)  allprojects{\n    repositories{\n        jcenter()\n        maven{\n            url 'https://jitpack.io'\n        }\n    }\n}  build.gradle (Module)  dependencies{\n    compile 'com.github.kevinwang5658:backstack:v2.3'\n}", 
            "title": "Adding BackStack"
        }, 
        {
            "location": "/getting_started/#initialization", 
            "text": "To initialize BackStack simply add the following code in onCreate().  public class MainActivity extends AppCompatActivity {\n\n    BackStackManager backStackManager;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        ...\n\n        BackStack.install(this);\n        backStackManager = BackStack.getBackStackManager();\n    }\n\n    @Override\n    public void onBackPressed() {\n        if (!backStackManager.goBack()) {\n            super.onBackPressed();\n        }\n    }\n}", 
            "title": "Initialization"
        }, 
        {
            "location": "/getting_started/#creating-a-simple-back-stack", 
            "text": "To begin we're going to focus on getting a linear back stack up and running. Linear back stacks are the main back stacks of this library. They are responsible for linear navigation flow  screenA -  screenB -  screenC . Linear back stacks will automatically implement back navigation and view hierarchy persistence.  Let's start shall we?  public static final String TAG =  TAG ;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    BackStack.install(this);\n    backStackManager = BackStack.getBackStackManager();\n\n    //This is the container you want to be the root of your back stack\n    root = findViewById(R.id.root);\n\n    LinearBackStack linearBackStack = backStackManager.createLinearBackStack( TAG , root, (layoutInflater, container) -  {\n        //This is our first view group in the stack\n        CustomViewGroup cvg = new CustomViewGroup(layoutInflater.getContext());\n\n        //Make sure that the view is added to container by the end of this block\n        container.addView(cvg);\n\n        //Return the view group that was newly inflated\n        return cvg;\n    });\n}  Let's make a view group called CustomViewGroup.  public class CustomViewGroup extends RelativeLayout{\n    public CustomViewGroup(Context context) {\n        super(context);\n\n        //Let's set the background color so that we know\n        //that the view group has been added\n        setBackgroundColor(Color.GRAY);\n\n        //Let's inflate an xml file with the children of this view group\n        LayoutInflater.from(context).inflate(R.layout.custom_view_group, this, true);\n    }\n}  And that's it. If you run this, you should see a gray screen instead of the default white. The first view group has been added to your stack.", 
            "title": "Creating a Simple Back Stack"
        }, 
        {
            "location": "/getting_started/#adding-subsequent-view-groups", 
            "text": "Now let's say that this gray screen is the home of our app, and that when we click on something we want to change to the next screen. Let's simulate this by setting an onClick listener on the entire screen.  public class CustomViewGroup extends RelativeLayout{\n    public CustomViewGroup(Context context) {\n        super(context);\n\n        //Let's set the background color so that we know\n        //that the view group has been added\n        setBackgroundColor(Color.GRAY);\n\n        //Let's inflate an xml file with the children of this view group\n        LayoutInflater.from(context).inflate(R.layout.custom_view_group, this, true);\n\n        setOnClickListener(v -  {\n\n        });\n\n    }\n}  This time let's inflate the view through xml as well just to change things up. So let's first create an xml layout file called added_view.xml  ?xml version= 1.0  encoding= utf-8 ?  com.rievo.test.AddedViewGroup xmlns:android= http://schemas.android.com/apk/res/android \n    android:layout_width= match_parent \n    android:layout_height= match_parent \n    android:background= @android:color/white \n     !-- Let's set the background color to white so that we can see a change--  /com.rievo.test.AddedViewGroup   Let's change our on click listener  setOnClickListener(v -  {\n    //All back stacks can be retrieved anywhere using their tag\n    LinearBackStack linearBackStack = (LinearBackStack) BackStack.getStack(MainActivity.TAG);\n    linearBackStack.add((layoutInflater, container) -  {\n        //if attach to root is true layoutInflater.inflate() returns the container instead\n        ViewGroup viewGroup = (ViewGroup) layoutInflater\n                .inflate(R.layout.added_view, container, false);\n        container.addView(viewGroup);\n        return viewGroup;\n    });\n});  Now let's try it. Clicking on the screen should change the screen color to white. Let's say this represents an info page or something. If you rotate your device you'll see that the screen remains white, this means that navigation stack was persisted. Pressing back should lead you back to the home screen. For more advanced usage of this library please proceed to the  next section .", 
            "title": "Adding Subsequent View Groups"
        }, 
        {
            "location": "/linear_back_stack/", 
            "text": "Linear Back Stack\n\n\nLinear back stacks are the core of BackStack. They are responsible for linear navigation flow \nscreenA -\n screenB -\n screen C\n. Linear back stacks have a root container view which it adds all view groups to. Under default behavior, linear back stacks will replace the previous view each time a new view is added, though this can be changed.\n\n\nInitialization\n\n\nLinear back stacks can be initialized in two ways. The first way is to use \nBackStackManager#createLinearBackStack(String, ViewGroup, ViewCreator)\n. This will initialize a linear back stack with a tag String, parent container ViewGroup and the ViewCreator for the first screen. All back stacks are associated with a unique tag. This facilitates access from anywhere in the code. Another way of initializing a linear back stack is to use a builder. This provides a lot more options on the configuration. To get the builder, call \nBackStackManager#builder(String)\n.\n\n\nThe options for the builder include:\n\n\nsetContainer(ViewGroup)\n: Sets the parent container\n\n\nuseCurrentViewGroup(ViewGroup)\n: Use the current view group as the first view and deduce the parent container view. This shouldn't be used alongside \nsetContainer(ViewGroup)\n\n\nsetRetain(boolean)\n: Sets the retain mode of the first view. Retained views won't be destroyed when more views are added, useful for expensive view groups.\n\n\nshouldAllowDuplicates(boolean)\n: Sets whether duplicate view creators should be allowed. View creator equality is determined by the equals function of each view creator. Make sure that is implemented properly for this to work.\n\n\nviewCreator(ViewCreator)\n: The view creator of the first view group on the stack. This must be set.\n\n\nbackStackManager.createLinearBackStack(TAG, container, (layoutInflater, container) -\n {\n    return null;\n});\n\nbackStackManager.builder(TAG)\n        .setContainer(container)\n        //You shouldn't use both setContainer and useCurrentViewGroup at the same time\n        .useCurrentViewGroup(container)\n        .shouldAllowDuplicates(false)\n        .shouldRetain(false)\n        .viewCreator((layoutInflater, container) -\n{\n            return null;\n        }).build();\n\n\n\n\nAdding Subsequent Views\n\n\nFrom anywhere in the app, all linear back stacks are accessible using \nBackStack#getStack(TAG)\n. After retrieval, linear back stacks have three options for adding new views, two overloaded methods and a builder.\n\n\nThe easiest way to add a view is to use \nLinearBackStack#add(ViewCreator)\n. This will push a view creator onto the stack and use it to inflate the view group. You can also specify a unique container to add the new view group using \nLinearBackStack#add(ViewCreator, ViewGroup)\n. The container must be on the same branch of and equal or lower down on the view hierarchy than the default container (it must be a parent of the default container or the default container itself). There is also a builder which provides the most options. To access the builder use \nLinearBackStack#Builder(ViewCreator)\n.\n\n\nThe options for the builder include:\n\n\nsetRetain(boolean)\n: Sets the retain mode of the newly added view. Retained views won't be destroyed when more views are added, useful for expensive view groups.\n\n\nsetContainer(ViewGroup)\n: Sets a custom container to add the view group in. The container must be on the same branch of and equal or lower down on the hierarchy than the default parent view group.\n\n\naddAnimator(Animator)\n: Sets the add animator. This will be called when new views are added. The \nAnimator#animate(ViewGroup, Emitter)\n method has two parameters: view, the view to play the animation on and emitter, something you have call when the animation ends.\n\n\nremoveAnimator(Animator)\n: Sets the remove animator. This animator is called when back is pressed and a view is removed. The rules are the same as the addAnimator.\n\n\nLinearBackStack linearBackStack = (LinearBackStack) BackStack.getStack(TAG);\n\nlinearBackStack.add((layoutInflater, viewGroup) -\n {\n    return null;\n});\n\nlinearBackStack.add((layoutInflater, viewGroup) -\n {\n    return null;\n}, container);\n\nlinearBackStack.builder((layoutInflater, viewGroup) -\n {\n    return null;\n})\n        .setRetain(true)\n        .setContainer(container)\n        .addAnimator((viewGroup, emitter) -\n {\n            emitter.done();\n        })\n        .removeAnimator((viewGroup, emitter) -\n {\n            emitter.done();\n        })\n        .build();\n\n\n\n\nHandling onBack Events Yourself\n\n\nTo handle onBack events yourself, implement the Reversible interface in the view group that you want to handle the call with. When that view group is about to be removed from the stack because of a onBack call, the \nReversible#onBack\n will be called to give the view a chance to handle the call. Returning true from this method means that you have handled the call and that BackStack doesn't need to do anything. Returning false means that you want BackStack to still handle the back event.\n\n\npublic class ViewGroup1 extends RelativeLayout implements Reversible{\n    public ViewGroup1(Context context) {\n        super(context);\n    }\n\n    @Override\n    public boolean onBack() {\n        return false;\n    }\n}", 
            "title": "Linear Back Stack"
        }, 
        {
            "location": "/linear_back_stack/#linear-back-stack", 
            "text": "Linear back stacks are the core of BackStack. They are responsible for linear navigation flow  screenA -  screenB -  screen C . Linear back stacks have a root container view which it adds all view groups to. Under default behavior, linear back stacks will replace the previous view each time a new view is added, though this can be changed.", 
            "title": "Linear Back Stack"
        }, 
        {
            "location": "/linear_back_stack/#initialization", 
            "text": "Linear back stacks can be initialized in two ways. The first way is to use  BackStackManager#createLinearBackStack(String, ViewGroup, ViewCreator) . This will initialize a linear back stack with a tag String, parent container ViewGroup and the ViewCreator for the first screen. All back stacks are associated with a unique tag. This facilitates access from anywhere in the code. Another way of initializing a linear back stack is to use a builder. This provides a lot more options on the configuration. To get the builder, call  BackStackManager#builder(String) .  The options for the builder include:  setContainer(ViewGroup) : Sets the parent container  useCurrentViewGroup(ViewGroup) : Use the current view group as the first view and deduce the parent container view. This shouldn't be used alongside  setContainer(ViewGroup)  setRetain(boolean) : Sets the retain mode of the first view. Retained views won't be destroyed when more views are added, useful for expensive view groups.  shouldAllowDuplicates(boolean) : Sets whether duplicate view creators should be allowed. View creator equality is determined by the equals function of each view creator. Make sure that is implemented properly for this to work.  viewCreator(ViewCreator) : The view creator of the first view group on the stack. This must be set.  backStackManager.createLinearBackStack(TAG, container, (layoutInflater, container) -  {\n    return null;\n});\n\nbackStackManager.builder(TAG)\n        .setContainer(container)\n        //You shouldn't use both setContainer and useCurrentViewGroup at the same time\n        .useCurrentViewGroup(container)\n        .shouldAllowDuplicates(false)\n        .shouldRetain(false)\n        .viewCreator((layoutInflater, container) - {\n            return null;\n        }).build();", 
            "title": "Initialization"
        }, 
        {
            "location": "/linear_back_stack/#adding-subsequent-views", 
            "text": "From anywhere in the app, all linear back stacks are accessible using  BackStack#getStack(TAG) . After retrieval, linear back stacks have three options for adding new views, two overloaded methods and a builder.  The easiest way to add a view is to use  LinearBackStack#add(ViewCreator) . This will push a view creator onto the stack and use it to inflate the view group. You can also specify a unique container to add the new view group using  LinearBackStack#add(ViewCreator, ViewGroup) . The container must be on the same branch of and equal or lower down on the view hierarchy than the default container (it must be a parent of the default container or the default container itself). There is also a builder which provides the most options. To access the builder use  LinearBackStack#Builder(ViewCreator) .  The options for the builder include:  setRetain(boolean) : Sets the retain mode of the newly added view. Retained views won't be destroyed when more views are added, useful for expensive view groups.  setContainer(ViewGroup) : Sets a custom container to add the view group in. The container must be on the same branch of and equal or lower down on the hierarchy than the default parent view group.  addAnimator(Animator) : Sets the add animator. This will be called when new views are added. The  Animator#animate(ViewGroup, Emitter)  method has two parameters: view, the view to play the animation on and emitter, something you have call when the animation ends.  removeAnimator(Animator) : Sets the remove animator. This animator is called when back is pressed and a view is removed. The rules are the same as the addAnimator.  LinearBackStack linearBackStack = (LinearBackStack) BackStack.getStack(TAG);\n\nlinearBackStack.add((layoutInflater, viewGroup) -  {\n    return null;\n});\n\nlinearBackStack.add((layoutInflater, viewGroup) -  {\n    return null;\n}, container);\n\nlinearBackStack.builder((layoutInflater, viewGroup) -  {\n    return null;\n})\n        .setRetain(true)\n        .setContainer(container)\n        .addAnimator((viewGroup, emitter) -  {\n            emitter.done();\n        })\n        .removeAnimator((viewGroup, emitter) -  {\n            emitter.done();\n        })\n        .build();", 
            "title": "Adding Subsequent Views"
        }, 
        {
            "location": "/linear_back_stack/#handling-onback-events-yourself", 
            "text": "To handle onBack events yourself, implement the Reversible interface in the view group that you want to handle the call with. When that view group is about to be removed from the stack because of a onBack call, the  Reversible#onBack  will be called to give the view a chance to handle the call. Returning true from this method means that you have handled the call and that BackStack doesn't need to do anything. Returning false means that you want BackStack to still handle the back event.  public class ViewGroup1 extends RelativeLayout implements Reversible{\n    public ViewGroup1(Context context) {\n        super(context);\n    }\n\n    @Override\n    public boolean onBack() {\n        return false;\n    }\n}", 
            "title": "Handling onBack Events Yourself"
        }, 
        {
            "location": "/split_back_stack/", 
            "text": "Split Back Stack\n\n\nSplit back stacks are responsible for distributing back events to the correct linear back stack in split navigation flows like bottom bars and view pagers. Currently the way that BackStack handles split navigation flows is that each tab will have it's own separate back stack. This means that in a given tab, pressing back will only give you the previous view in the same tab. We might add multiple tab back stacks in the future.\n\n\nA split back stack isn't a real back stack. It doesn't hold view creators and can't inflate views. This is left to be the responsibility of the developer to implement since it varies greatly between different containers (bottom bars are way different to view pagers). A split back stack simply delegates back events to the correct linear back stack to handle the touch event.\n\n\nBasic Usage\n\n\nSplit back stacks are created similarly to linear back stacks. Use \nBackStackManager#createSplitBackStack(String, int)\n. The string is the unique tag associated with the split back stack. The int is the default position of the back stack.\n\n\nSplit back stacks don't store view creators, instead they store TAGs that are associated with the linear back stacks within them. To add a new linearBackStack use \nSplitBackStack#add(int, String)\n. The int is the position of the linear back stack within the split back stack and the String is the TAG associated with it.\n\n\nSplitBackStack splitBackStack = backStackManager.createSplitBackStack(SPLIT_TAG, 0);\n\nsplitBackStack.add(position, tag);\n\n\n\n\nExamples\n\n\nView Pagers\n\n\nTo use a split back stack with a view pager, you have to add a unique linear back stack in \nPagerAdapter#instantiateItem(ViewGroup, int)\n. This method comes with a container and it may be tempting to use this container as the root container of the linear back stack but this won't work properly. View pagers don't like it when views are added or removed from the container independent of the adapter. To remedy this, we need to add an extra view to be the container of our linear back stacks.\n\n\n@Override\npublic Object instantiateItem(ViewGroup container, int position) {\n    // View Pagers doesn't like it when you remove a view from the container.\n    // We need to add an extra view so that we can add and remove views to it at will\n    ViewGroup parent = new RelativeLayout(container.getContext());\n    container.addView(parent);\n\n    //Just being lazy. If you're inflating unique view groups, you should store a unique tag\n    //in each one\n    String tag = TAG + position;\n\n    backStackManager.createLinearBackStack(tag, parent, (layoutInflater, viewGroup) -\n {\n        ViewGroup vg = (ViewGroup) layoutInflater.inflate(R.layout.view_group1, viewGroup, false);\n        viewGroup.addView(vg);\n        return vg;\n    });\n\n    //Remember to actually add the linear back stack to the split back stack\n    splitBackStack.add(position, tag);\n\n    return parent;\n}\n\n\n\n\nAdditionally we need to override \nPagerAdapter#destroyItem(ViewGroup, int, Object)\n to remove our container view group and destroy our added linear back stacks.\n\n\n@Override\npublic void destroyItem(ViewGroup container, int position, Object object) {\n    //If you remove a view you must call splitBackStack#remove(int)\n    splitBackStack.remove(position);\n\n    //Standard view pager adapter procedure\n    container.removeView((ViewGroup) object);\n}\n\n\n\n\nOverall the class looks like this:\n\n\npublic class ViewPagerAdapter extends PagerAdapter {\n\n    public static final int NUM_PAGES = 3;\n    public static final String SPLIT_TAG = \nSPLIT_TAG\n;\n    public static final String TAG = \nTAG\n;\n\n    private BackStackManager backStackManager = BackStack.getBackStackManager();\n    private SplitBackStack splitBackStack = backStackManager.createSplitBackStack(SPLIT_TAG, 0);\n\n    @Override\n    public Object instantiateItem(ViewGroup container, int position) {\n        // View Pagers doesn't like it when you remove a view from the container.\n        // We need to add an extra view so that we can add and remove views to it at will\n        ViewGroup parent = new RelativeLayout(container.getContext());\n        container.addView(parent);\n\n        //Just being lazy. If you're inflating unique view groups, you should store a unique tag\n        //in each one\n        String tag = TAG + position;\n\n        backStackManager.createLinearBackStack(tag, parent, (layoutInflater, viewGroup) -\n {\n            ViewGroup vg = (ViewGroup) layoutInflater.inflate(R.layout.view_group1, viewGroup, false);\n            viewGroup.addView(vg);\n            return vg;\n        });\n\n        //Remember to actually add the linear back stack to the split back stack\n        splitBackStack.add(position, tag);\n\n        return parent;\n    }\n\n    @Override\n    public void destroyItem(ViewGroup container, int position, Object object) {\n        //If you remove a view you must call splitBackStack#remove(int)\n        splitBackStack.remove(position);\n\n        //Standard view pager adapter procedure\n        container.removeView((ViewGroup) object);\n    }\n\n    @Override\n    public int getCount() {\n        return NUM_PAGES;\n    }\n\n    @Override\n    public boolean isViewFromObject(View view, Object object) {\n        return view == object;\n    }\n}\n\n\n\n\nWe also need to make the split back stack aware of page changes. This way it knows which linear back stack should receive the go back calls.\n\n\nviewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {\n    @Override\n    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n\n    }\n\n    @Override\n    public void onPageSelected(int position) {\n        ((SplitBackStack) BackStack.getStack(SPLIT_TAG)).changePosition(position);\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int state) {\n\n    }\n});\n\n\n\n\nYour split back stack should now work properly with the view pager. Under this configuration, each page will have it's own independent back stack.\n\n\nBottom bar\n\n\nSplit back stacks also works with bottom bars. The developer is responsible for adding all the view groups needed and making an independent linear back stack for each tab. They are also responsible for switching view groups and alerting the split back stack when the user presses a new tab.\n\n\nLet's make a bottom bar with 3 tabs. Config the bottom bar as normal using a menu xml file. For this demo we're going to keep all three tabs visible and we're going to use \nViewGroup#bringChildToFront(View)\n to switch which child is shown.\n\n\nBackStack.install(this);\nbackStackManager = BackStack.getBackStackManager();\nsplitBackStack = backStackManager.createSplitBackStack(SPLIT_TAG, 0);\n\nroot = findViewById(R.id.root);\nbottomBar = findViewById(R.id.bottom_bar);\n\nbackStackManager.createLinearBackStack(ViewGroup1.TAG, root, (layoutInflater, container)-\n{\n   ViewGroup1 viewGroup = new ViewGroup1(layoutInflater.getContext());\n   container.addView(viewGroup);\n   return viewGroup;\n});\nsplitBackStack.add(0, ViewGroup1.TAG);\n\nbackStackManager.createLinearBackStack(ViewGroup2.TAG, root, (layoutInflater, container) -\n {\n    ViewGroup2 viewGroup = new ViewGroup2(layoutInflater.getContext());\n    container.addView(viewGroup);\n    return viewGroup;\n});\nsplitBackStack.add(1, ViewGroup2.TAG);\n\nbackStackManager.createLinearBackStack(ViewGroup3.TAG, root, (layoutInflater, container) -\n {\n    ViewGroup3 viewGroup = new ViewGroup3(layoutInflater.getContext());\n    container.addView(viewGroup);\n    return viewGroup;\n});\nsplitBackStack.add(2, ViewGroup3.TAG);\n\nroot.bringChildToFront(((LinearBackStack) backStackManager.getStack(ViewGroup1.TAG)).getCurrentView());\n\n\n\n\nNext we're going to add a on tab change listener to the bottom bar. This will alert the split back stack which position the bar is currently at. In this method, we're also going to bring the selected view to the front so that it's shown.\n\n\nbottomBar.setOnNavigationItemSelectedListener(new BottomNavigationView.OnNavigationItemSelectedListener() {\n    @Override\n    public boolean onNavigationItemSelected(@NonNull MenuItem item) {\n        //Couldn't find a way of getting the position. Had to do this instead\n        int position = 0;\n        switch (item.getItemId()){\n            case R.id.first:position = 0; break;\n            case R.id.second: position = 1; break;\n            case R.id.third: position = 2; break;\n        }\n\n        root.bringChildToFront(((LinearBackStack)BackStack.getStack(splitBackStack.getTAG(position)))\n                .getCurrentView());\n        splitBackStack.changePosition(position);\n\n        return true;\n    }\n});", 
            "title": "Split Back Stack"
        }, 
        {
            "location": "/split_back_stack/#split-back-stack", 
            "text": "Split back stacks are responsible for distributing back events to the correct linear back stack in split navigation flows like bottom bars and view pagers. Currently the way that BackStack handles split navigation flows is that each tab will have it's own separate back stack. This means that in a given tab, pressing back will only give you the previous view in the same tab. We might add multiple tab back stacks in the future.  A split back stack isn't a real back stack. It doesn't hold view creators and can't inflate views. This is left to be the responsibility of the developer to implement since it varies greatly between different containers (bottom bars are way different to view pagers). A split back stack simply delegates back events to the correct linear back stack to handle the touch event.", 
            "title": "Split Back Stack"
        }, 
        {
            "location": "/split_back_stack/#basic-usage", 
            "text": "Split back stacks are created similarly to linear back stacks. Use  BackStackManager#createSplitBackStack(String, int) . The string is the unique tag associated with the split back stack. The int is the default position of the back stack.  Split back stacks don't store view creators, instead they store TAGs that are associated with the linear back stacks within them. To add a new linearBackStack use  SplitBackStack#add(int, String) . The int is the position of the linear back stack within the split back stack and the String is the TAG associated with it.  SplitBackStack splitBackStack = backStackManager.createSplitBackStack(SPLIT_TAG, 0);\n\nsplitBackStack.add(position, tag);", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/split_back_stack/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/split_back_stack/#view-pagers", 
            "text": "To use a split back stack with a view pager, you have to add a unique linear back stack in  PagerAdapter#instantiateItem(ViewGroup, int) . This method comes with a container and it may be tempting to use this container as the root container of the linear back stack but this won't work properly. View pagers don't like it when views are added or removed from the container independent of the adapter. To remedy this, we need to add an extra view to be the container of our linear back stacks.  @Override\npublic Object instantiateItem(ViewGroup container, int position) {\n    // View Pagers doesn't like it when you remove a view from the container.\n    // We need to add an extra view so that we can add and remove views to it at will\n    ViewGroup parent = new RelativeLayout(container.getContext());\n    container.addView(parent);\n\n    //Just being lazy. If you're inflating unique view groups, you should store a unique tag\n    //in each one\n    String tag = TAG + position;\n\n    backStackManager.createLinearBackStack(tag, parent, (layoutInflater, viewGroup) -  {\n        ViewGroup vg = (ViewGroup) layoutInflater.inflate(R.layout.view_group1, viewGroup, false);\n        viewGroup.addView(vg);\n        return vg;\n    });\n\n    //Remember to actually add the linear back stack to the split back stack\n    splitBackStack.add(position, tag);\n\n    return parent;\n}  Additionally we need to override  PagerAdapter#destroyItem(ViewGroup, int, Object)  to remove our container view group and destroy our added linear back stacks.  @Override\npublic void destroyItem(ViewGroup container, int position, Object object) {\n    //If you remove a view you must call splitBackStack#remove(int)\n    splitBackStack.remove(position);\n\n    //Standard view pager adapter procedure\n    container.removeView((ViewGroup) object);\n}  Overall the class looks like this:  public class ViewPagerAdapter extends PagerAdapter {\n\n    public static final int NUM_PAGES = 3;\n    public static final String SPLIT_TAG =  SPLIT_TAG ;\n    public static final String TAG =  TAG ;\n\n    private BackStackManager backStackManager = BackStack.getBackStackManager();\n    private SplitBackStack splitBackStack = backStackManager.createSplitBackStack(SPLIT_TAG, 0);\n\n    @Override\n    public Object instantiateItem(ViewGroup container, int position) {\n        // View Pagers doesn't like it when you remove a view from the container.\n        // We need to add an extra view so that we can add and remove views to it at will\n        ViewGroup parent = new RelativeLayout(container.getContext());\n        container.addView(parent);\n\n        //Just being lazy. If you're inflating unique view groups, you should store a unique tag\n        //in each one\n        String tag = TAG + position;\n\n        backStackManager.createLinearBackStack(tag, parent, (layoutInflater, viewGroup) -  {\n            ViewGroup vg = (ViewGroup) layoutInflater.inflate(R.layout.view_group1, viewGroup, false);\n            viewGroup.addView(vg);\n            return vg;\n        });\n\n        //Remember to actually add the linear back stack to the split back stack\n        splitBackStack.add(position, tag);\n\n        return parent;\n    }\n\n    @Override\n    public void destroyItem(ViewGroup container, int position, Object object) {\n        //If you remove a view you must call splitBackStack#remove(int)\n        splitBackStack.remove(position);\n\n        //Standard view pager adapter procedure\n        container.removeView((ViewGroup) object);\n    }\n\n    @Override\n    public int getCount() {\n        return NUM_PAGES;\n    }\n\n    @Override\n    public boolean isViewFromObject(View view, Object object) {\n        return view == object;\n    }\n}  We also need to make the split back stack aware of page changes. This way it knows which linear back stack should receive the go back calls.  viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {\n    @Override\n    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n\n    }\n\n    @Override\n    public void onPageSelected(int position) {\n        ((SplitBackStack) BackStack.getStack(SPLIT_TAG)).changePosition(position);\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int state) {\n\n    }\n});  Your split back stack should now work properly with the view pager. Under this configuration, each page will have it's own independent back stack.", 
            "title": "View Pagers"
        }, 
        {
            "location": "/split_back_stack/#bottom-bar", 
            "text": "Split back stacks also works with bottom bars. The developer is responsible for adding all the view groups needed and making an independent linear back stack for each tab. They are also responsible for switching view groups and alerting the split back stack when the user presses a new tab.  Let's make a bottom bar with 3 tabs. Config the bottom bar as normal using a menu xml file. For this demo we're going to keep all three tabs visible and we're going to use  ViewGroup#bringChildToFront(View)  to switch which child is shown.  BackStack.install(this);\nbackStackManager = BackStack.getBackStackManager();\nsplitBackStack = backStackManager.createSplitBackStack(SPLIT_TAG, 0);\n\nroot = findViewById(R.id.root);\nbottomBar = findViewById(R.id.bottom_bar);\n\nbackStackManager.createLinearBackStack(ViewGroup1.TAG, root, (layoutInflater, container)- {\n   ViewGroup1 viewGroup = new ViewGroup1(layoutInflater.getContext());\n   container.addView(viewGroup);\n   return viewGroup;\n});\nsplitBackStack.add(0, ViewGroup1.TAG);\n\nbackStackManager.createLinearBackStack(ViewGroup2.TAG, root, (layoutInflater, container) -  {\n    ViewGroup2 viewGroup = new ViewGroup2(layoutInflater.getContext());\n    container.addView(viewGroup);\n    return viewGroup;\n});\nsplitBackStack.add(1, ViewGroup2.TAG);\n\nbackStackManager.createLinearBackStack(ViewGroup3.TAG, root, (layoutInflater, container) -  {\n    ViewGroup3 viewGroup = new ViewGroup3(layoutInflater.getContext());\n    container.addView(viewGroup);\n    return viewGroup;\n});\nsplitBackStack.add(2, ViewGroup3.TAG);\n\nroot.bringChildToFront(((LinearBackStack) backStackManager.getStack(ViewGroup1.TAG)).getCurrentView());  Next we're going to add a on tab change listener to the bottom bar. This will alert the split back stack which position the bar is currently at. In this method, we're also going to bring the selected view to the front so that it's shown.  bottomBar.setOnNavigationItemSelectedListener(new BottomNavigationView.OnNavigationItemSelectedListener() {\n    @Override\n    public boolean onNavigationItemSelected(@NonNull MenuItem item) {\n        //Couldn't find a way of getting the position. Had to do this instead\n        int position = 0;\n        switch (item.getItemId()){\n            case R.id.first:position = 0; break;\n            case R.id.second: position = 1; break;\n            case R.id.third: position = 2; break;\n        }\n\n        root.bringChildToFront(((LinearBackStack)BackStack.getStack(splitBackStack.getTAG(position)))\n                .getCurrentView());\n        splitBackStack.changePosition(position);\n\n        return true;\n    }\n});", 
            "title": "Bottom bar"
        }, 
        {
            "location": "/view_creator/", 
            "text": "View Creators\n\n\nView creators is the core of the BackStack library. They allow the library to instantiate any view group at any time regardless of the order and conditions they were added in. A view creator is just a functional interface that the developer will have to implement. View creators have 2 rules that developers must abide by. First, by the end of the create function, the inflated view must be added to the provided container. Second, the view creator should not capture a reference to the activity in any way. This means that anonymous inner functions can't be used since they implicitly capture the surrounding outer class. Lambdas don't implicitly capture and can be used.\n\n\nHere's some tips and tricks with view creators.\n\n\nInflating xml\n\n\nInstead of creating a creating a custom view group through code and then inflating a layout xml inside of the constructor, you can directly inflate an xml with the custom view group as a base. This prevents an unnecessary container from being added.\n\n\nViewGroup layout xml\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\ncom.rievo.test2.ViewGroup1\n   xmlns:android=\nhttp://schemas.android.com/apk/res/android\n\n   android:orientation=\nvertical\n android:layout_width=\nmatch_parent\n\n   android:layout_height=\nmatch_parent\n\n   android:background=\n@android:color/holo_orange_light\n\n   \nTextView\n       android:layout_width=\nwrap_content\n\n       android:layout_height=\nwrap_content\n\n       android:text=\n1\n/\n\n\n\n/com.rievo.test2.ViewGroup1\n\n\n\n\n\nInflation code\n\n\nlinearBackStack.add((layoutInflater, container) -\n {\n   ViewGroup viewGroup = (ViewGroup) layoutInflater.inflate(R.layout.view_group1, container, false);\n   container.addView(viewGroup);\n   return viewGroup;\n});\n\n\n\n\nStoring State\n\n\nIf inflating using a constructor, it may be useful to pass state using the view group's constructor. This can't be done when using fragments or activities which require you use the default constructor. Passing in state  is useful in situations where you want to pass in information for the new view group to display, such as an information page. In order to not capture the activity, a standalone class or a static inner class must be used.\n\n\npublic static class MyViewCreator implements ViewCreator{\n\n    Object state;\n\n    MyViewCreator(Object myState){\n        state = myState;\n    }\n\n    @Override\n    public ViewGroup create(LayoutInflater layoutInflater, ViewGroup container) {\n        ViewGroup1 viewGroup = new ViewGroup1(layoutInflater.getContext(), state);\n        container.addView(viewGroup);\n        return viewGroup;\n    }\n}", 
            "title": "View Creators"
        }, 
        {
            "location": "/view_creator/#view-creators", 
            "text": "View creators is the core of the BackStack library. They allow the library to instantiate any view group at any time regardless of the order and conditions they were added in. A view creator is just a functional interface that the developer will have to implement. View creators have 2 rules that developers must abide by. First, by the end of the create function, the inflated view must be added to the provided container. Second, the view creator should not capture a reference to the activity in any way. This means that anonymous inner functions can't be used since they implicitly capture the surrounding outer class. Lambdas don't implicitly capture and can be used.  Here's some tips and tricks with view creators.", 
            "title": "View Creators"
        }, 
        {
            "location": "/view_creator/#inflating-xml", 
            "text": "Instead of creating a creating a custom view group through code and then inflating a layout xml inside of the constructor, you can directly inflate an xml with the custom view group as a base. This prevents an unnecessary container from being added.  ViewGroup layout xml  ?xml version= 1.0  encoding= utf-8 ?  com.rievo.test2.ViewGroup1\n   xmlns:android= http://schemas.android.com/apk/res/android \n   android:orientation= vertical  android:layout_width= match_parent \n   android:layout_height= match_parent \n   android:background= @android:color/holo_orange_light \n    TextView\n       android:layout_width= wrap_content \n       android:layout_height= wrap_content \n       android:text= 1 /  /com.rievo.test2.ViewGroup1   Inflation code  linearBackStack.add((layoutInflater, container) -  {\n   ViewGroup viewGroup = (ViewGroup) layoutInflater.inflate(R.layout.view_group1, container, false);\n   container.addView(viewGroup);\n   return viewGroup;\n});", 
            "title": "Inflating xml"
        }, 
        {
            "location": "/view_creator/#storing-state", 
            "text": "If inflating using a constructor, it may be useful to pass state using the view group's constructor. This can't be done when using fragments or activities which require you use the default constructor. Passing in state  is useful in situations where you want to pass in information for the new view group to display, such as an information page. In order to not capture the activity, a standalone class or a static inner class must be used.  public static class MyViewCreator implements ViewCreator{\n\n    Object state;\n\n    MyViewCreator(Object myState){\n        state = myState;\n    }\n\n    @Override\n    public ViewGroup create(LayoutInflater layoutInflater, ViewGroup container) {\n        ViewGroup1 viewGroup = new ViewGroup1(layoutInflater.getContext(), state);\n        container.addView(viewGroup);\n        return viewGroup;\n    }\n}", 
            "title": "Storing State"
        }, 
        {
            "location": "/license/", 
            "text": "License\n\n\nApache License\nVersion 2.0, January 2004\nhttp://www.apache.org/licenses/\n\n\nTERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n\n\n\nDefinitions.\n\n\n\n\n\"License\" shall mean the terms and conditions for use, reproduction,\nand distribution as defined by Sections 1 through 9 of this document.\n\n\n\"Licensor\" shall mean the copyright owner or entity authorized by\nthe copyright owner that is granting the License.\n\n\n\"Legal Entity\" shall mean the union of the acting entity and all\nother entities that control, are controlled by, or are under common\ncontrol with that entity. For the purposes of this definition,\n\"control\" means (i) the power, direct or indirect, to cause the\ndirection or management of such entity, whether by contract or\notherwise, or (ii) ownership of fifty percent (50%) or more of the\noutstanding shares, or (iii) beneficial ownership of such entity.\n\n\n\"You\" (or \"Your\") shall mean an individual or Legal Entity\nexercising permissions granted by this License.\n\n\n\"Source\" form shall mean the preferred form for making modifications,\nincluding but not limited to software source code, documentation\nsource, and configuration files.\n\n\n\"Object\" form shall mean any form resulting from mechanical\ntransformation or translation of a Source form, including but\nnot limited to compiled object code, generated documentation,\nand conversions to other media types.\n\n\n\"Work\" shall mean the work of authorship, whether in Source or\nObject form, made available under the License, as indicated by a\ncopyright notice that is included in or attached to the work\n(an example is provided in the Appendix below).\n\n\n\"Derivative Works\" shall mean any work, whether in Source or Object\nform, that is based on (or derived from) the Work and for which the\neditorial revisions, annotations, elaborations, or other modifications\nrepresent, as a whole, an original work of authorship. For the purposes\nof this License, Derivative Works shall not include works that remain\nseparable from, or merely link (or bind by name) to the interfaces of,\nthe Work and Derivative Works thereof.\n\n\n\"Contribution\" shall mean any work of authorship, including\nthe original version of the Work and any modifications or additions\nto that Work or Derivative Works thereof, that is intentionally\nsubmitted to Licensor for inclusion in the Work by the copyright owner\nor by an individual or Legal Entity authorized to submit on behalf of\nthe copyright owner. For the purposes of this definition, \"submitted\"\nmeans any form of electronic, verbal, or written communication sent\nto the Licensor or its representatives, including but not limited to\ncommunication on electronic mailing lists, source code control systems,\nand issue tracking systems that are managed by, or on behalf of, the\nLicensor for the purpose of discussing and improving the Work, but\nexcluding communication that is conspicuously marked or otherwise\ndesignated in writing by the copyright owner as \"Not a Contribution.\"\n\n\n\"Contributor\" shall mean Licensor and any individual or Legal Entity\non behalf of whom a Contribution has been received by Licensor and\nsubsequently incorporated within the Work.\n\n\n\n\n\n\nGrant of Copyright License. Subject to the terms and conditions of\nthis License, each Contributor hereby grants to You a perpetual,\nworldwide, non-exclusive, no-charge, royalty-free, irrevocable\ncopyright license to reproduce, prepare Derivative Works of,\npublicly display, publicly perform, sublicense, and distribute the\nWork and such Derivative Works in Source or Object form.\n\n\n\n\n\n\nGrant of Patent License. Subject to the terms and conditions of\nthis License, each Contributor hereby grants to You a perpetual,\nworldwide, non-exclusive, no-charge, royalty-free, irrevocable\n(except as stated in this section) patent license to make, have made,\nuse, offer to sell, sell, import, and otherwise transfer the Work,\nwhere such license applies only to those patent claims licensable\nby such Contributor that are necessarily infringed by their\nContribution(s) alone or by combination of their Contribution(s)\nwith the Work to which such Contribution(s) was submitted. If You\ninstitute patent litigation against any entity (including a\ncross-claim or counterclaim in a lawsuit) alleging that the Work\nor a Contribution incorporated within the Work constitutes direct\nor contributory patent infringement, then any patent licenses\ngranted to You under this License for that Work shall terminate\nas of the date such litigation is filed.\n\n\n\n\n\n\nRedistribution. You may reproduce and distribute copies of the\nWork or Derivative Works thereof in any medium, with or without\nmodifications, and in Source or Object form, provided that You\nmeet the following conditions:\n\n\n\n\n\n\n(a) You must give any other recipients of the Work or\nDerivative Works a copy of this License; and\n\n\n(b) You must cause any modified files to carry prominent notices\nstating that You changed the files; and\n\n\n(c) You must retain, in the Source form of any Derivative Works\nthat You distribute, all copyright, patent, trademark, and\nattribution notices from the Source form of the Work,\nexcluding those notices that do not pertain to any part of\nthe Derivative Works; and\n\n\n(d) If the Work includes a \"NOTICE\" text file as part of its\ndistribution, then any Derivative Works that You distribute must\ninclude a readable copy of the attribution notices contained\nwithin such NOTICE file, excluding those notices that do not\npertain to any part of the Derivative Works, in at least one\nof the following places: within a NOTICE text file distributed\nas part of the Derivative Works; within the Source form or\ndocumentation, if provided along with the Derivative Works; or,\nwithin a display generated by the Derivative Works, if and\nwherever such third-party notices normally appear. The contents\nof the NOTICE file are for informational purposes only and\ndo not modify the License. You may add Your own attribution\nnotices within Derivative Works that You distribute, alongside\nor as an addendum to the NOTICE text from the Work, provided\nthat such additional attribution notices cannot be construed\nas modifying the License.\n\n\nYou may add Your own copyright statement to Your modifications and\nmay provide additional or different license terms and conditions\nfor use, reproduction, or distribution of Your modifications, or\nfor any such Derivative Works as a whole, provided Your use,\nreproduction, and distribution of the Work otherwise complies with\nthe conditions stated in this License.\n\n\n\n\n\n\nSubmission of Contributions. Unless You explicitly state otherwise,\nany Contribution intentionally submitted for inclusion in the Work\nby You to the Licensor shall be under the terms and conditions of\nthis License, without any additional terms or conditions.\nNotwithstanding the above, nothing herein shall supersede or modify\nthe terms of any separate license agreement you may have executed\nwith Licensor regarding such Contributions.\n\n\n\n\n\n\nTrademarks. This License does not grant permission to use the trade\nnames, trademarks, service marks, or product names of the Licensor,\nexcept as required for reasonable and customary use in describing the\norigin of the Work and reproducing the content of the NOTICE file.\n\n\n\n\n\n\nDisclaimer of Warranty. Unless required by applicable law or\nagreed to in writing, Licensor provides the Work (and each\nContributor provides its Contributions) on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\nimplied, including, without limitation, any warranties or conditions\nof TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\nPARTICULAR PURPOSE. You are solely responsible for determining the\nappropriateness of using or redistributing the Work and assume any\nrisks associated with Your exercise of permissions under this License.\n\n\n\n\n\n\nLimitation of Liability. In no event and under no legal theory,\nwhether in tort (including negligence), contract, or otherwise,\nunless required by applicable law (such as deliberate and grossly\nnegligent acts) or agreed to in writing, shall any Contributor be\nliable to You for damages, including any direct, indirect, special,\nincidental, or consequential damages of any character arising as a\nresult of this License or out of the use or inability to use the\nWork (including but not limited to damages for loss of goodwill,\nwork stoppage, computer failure or malfunction, or any and all\nother commercial damages or losses), even if such Contributor\nhas been advised of the possibility of such damages.\n\n\n\n\n\n\nAccepting Warranty or Additional Liability. While redistributing\nthe Work or Derivative Works thereof, You may choose to offer,\nand charge a fee for, acceptance of support, warranty, indemnity,\nor other liability obligations and/or rights consistent with this\nLicense. However, in accepting such obligations, You may act only\non Your own behalf and on Your sole responsibility, not on behalf\nof any other Contributor, and only if You agree to indemnify,\ndefend, and hold each Contributor harmless for any liability\nincurred by, or claims asserted against, such Contributor by reason\nof your accepting any such warranty or additional liability.\n\n\n\n\n\n\nEND OF TERMS AND CONDITIONS\n\n\nAPPENDIX: How to apply the Apache License to your work.\n\n\nTo apply the Apache License to your work, attach the following\nboilerplate notice, with the fields enclosed by brackets \"{}\"\nreplaced with your own identifying information. (Don't include\nthe brackets!)  The text should be enclosed in the appropriate\ncomment syntax for the file format. We also recommend that a\nfile or class name and description of purpose be included on the\nsame \"printed page\" as the copyright notice for easier\nidentification within third-party archives.\n\n\nCopyright 2017 Kevin Wang\n\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.", 
            "title": "License"
        }, 
        {
            "location": "/license/#license", 
            "text": "Apache License\nVersion 2.0, January 2004\nhttp://www.apache.org/licenses/  TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION   Definitions.   \"License\" shall mean the terms and conditions for use, reproduction,\nand distribution as defined by Sections 1 through 9 of this document.  \"Licensor\" shall mean the copyright owner or entity authorized by\nthe copyright owner that is granting the License.  \"Legal Entity\" shall mean the union of the acting entity and all\nother entities that control, are controlled by, or are under common\ncontrol with that entity. For the purposes of this definition,\n\"control\" means (i) the power, direct or indirect, to cause the\ndirection or management of such entity, whether by contract or\notherwise, or (ii) ownership of fifty percent (50%) or more of the\noutstanding shares, or (iii) beneficial ownership of such entity.  \"You\" (or \"Your\") shall mean an individual or Legal Entity\nexercising permissions granted by this License.  \"Source\" form shall mean the preferred form for making modifications,\nincluding but not limited to software source code, documentation\nsource, and configuration files.  \"Object\" form shall mean any form resulting from mechanical\ntransformation or translation of a Source form, including but\nnot limited to compiled object code, generated documentation,\nand conversions to other media types.  \"Work\" shall mean the work of authorship, whether in Source or\nObject form, made available under the License, as indicated by a\ncopyright notice that is included in or attached to the work\n(an example is provided in the Appendix below).  \"Derivative Works\" shall mean any work, whether in Source or Object\nform, that is based on (or derived from) the Work and for which the\neditorial revisions, annotations, elaborations, or other modifications\nrepresent, as a whole, an original work of authorship. For the purposes\nof this License, Derivative Works shall not include works that remain\nseparable from, or merely link (or bind by name) to the interfaces of,\nthe Work and Derivative Works thereof.  \"Contribution\" shall mean any work of authorship, including\nthe original version of the Work and any modifications or additions\nto that Work or Derivative Works thereof, that is intentionally\nsubmitted to Licensor for inclusion in the Work by the copyright owner\nor by an individual or Legal Entity authorized to submit on behalf of\nthe copyright owner. For the purposes of this definition, \"submitted\"\nmeans any form of electronic, verbal, or written communication sent\nto the Licensor or its representatives, including but not limited to\ncommunication on electronic mailing lists, source code control systems,\nand issue tracking systems that are managed by, or on behalf of, the\nLicensor for the purpose of discussing and improving the Work, but\nexcluding communication that is conspicuously marked or otherwise\ndesignated in writing by the copyright owner as \"Not a Contribution.\"  \"Contributor\" shall mean Licensor and any individual or Legal Entity\non behalf of whom a Contribution has been received by Licensor and\nsubsequently incorporated within the Work.    Grant of Copyright License. Subject to the terms and conditions of\nthis License, each Contributor hereby grants to You a perpetual,\nworldwide, non-exclusive, no-charge, royalty-free, irrevocable\ncopyright license to reproduce, prepare Derivative Works of,\npublicly display, publicly perform, sublicense, and distribute the\nWork and such Derivative Works in Source or Object form.    Grant of Patent License. Subject to the terms and conditions of\nthis License, each Contributor hereby grants to You a perpetual,\nworldwide, non-exclusive, no-charge, royalty-free, irrevocable\n(except as stated in this section) patent license to make, have made,\nuse, offer to sell, sell, import, and otherwise transfer the Work,\nwhere such license applies only to those patent claims licensable\nby such Contributor that are necessarily infringed by their\nContribution(s) alone or by combination of their Contribution(s)\nwith the Work to which such Contribution(s) was submitted. If You\ninstitute patent litigation against any entity (including a\ncross-claim or counterclaim in a lawsuit) alleging that the Work\nor a Contribution incorporated within the Work constitutes direct\nor contributory patent infringement, then any patent licenses\ngranted to You under this License for that Work shall terminate\nas of the date such litigation is filed.    Redistribution. You may reproduce and distribute copies of the\nWork or Derivative Works thereof in any medium, with or without\nmodifications, and in Source or Object form, provided that You\nmeet the following conditions:    (a) You must give any other recipients of the Work or\nDerivative Works a copy of this License; and  (b) You must cause any modified files to carry prominent notices\nstating that You changed the files; and  (c) You must retain, in the Source form of any Derivative Works\nthat You distribute, all copyright, patent, trademark, and\nattribution notices from the Source form of the Work,\nexcluding those notices that do not pertain to any part of\nthe Derivative Works; and  (d) If the Work includes a \"NOTICE\" text file as part of its\ndistribution, then any Derivative Works that You distribute must\ninclude a readable copy of the attribution notices contained\nwithin such NOTICE file, excluding those notices that do not\npertain to any part of the Derivative Works, in at least one\nof the following places: within a NOTICE text file distributed\nas part of the Derivative Works; within the Source form or\ndocumentation, if provided along with the Derivative Works; or,\nwithin a display generated by the Derivative Works, if and\nwherever such third-party notices normally appear. The contents\nof the NOTICE file are for informational purposes only and\ndo not modify the License. You may add Your own attribution\nnotices within Derivative Works that You distribute, alongside\nor as an addendum to the NOTICE text from the Work, provided\nthat such additional attribution notices cannot be construed\nas modifying the License.  You may add Your own copyright statement to Your modifications and\nmay provide additional or different license terms and conditions\nfor use, reproduction, or distribution of Your modifications, or\nfor any such Derivative Works as a whole, provided Your use,\nreproduction, and distribution of the Work otherwise complies with\nthe conditions stated in this License.    Submission of Contributions. Unless You explicitly state otherwise,\nany Contribution intentionally submitted for inclusion in the Work\nby You to the Licensor shall be under the terms and conditions of\nthis License, without any additional terms or conditions.\nNotwithstanding the above, nothing herein shall supersede or modify\nthe terms of any separate license agreement you may have executed\nwith Licensor regarding such Contributions.    Trademarks. This License does not grant permission to use the trade\nnames, trademarks, service marks, or product names of the Licensor,\nexcept as required for reasonable and customary use in describing the\norigin of the Work and reproducing the content of the NOTICE file.    Disclaimer of Warranty. Unless required by applicable law or\nagreed to in writing, Licensor provides the Work (and each\nContributor provides its Contributions) on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\nimplied, including, without limitation, any warranties or conditions\nof TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\nPARTICULAR PURPOSE. You are solely responsible for determining the\nappropriateness of using or redistributing the Work and assume any\nrisks associated with Your exercise of permissions under this License.    Limitation of Liability. In no event and under no legal theory,\nwhether in tort (including negligence), contract, or otherwise,\nunless required by applicable law (such as deliberate and grossly\nnegligent acts) or agreed to in writing, shall any Contributor be\nliable to You for damages, including any direct, indirect, special,\nincidental, or consequential damages of any character arising as a\nresult of this License or out of the use or inability to use the\nWork (including but not limited to damages for loss of goodwill,\nwork stoppage, computer failure or malfunction, or any and all\nother commercial damages or losses), even if such Contributor\nhas been advised of the possibility of such damages.    Accepting Warranty or Additional Liability. While redistributing\nthe Work or Derivative Works thereof, You may choose to offer,\nand charge a fee for, acceptance of support, warranty, indemnity,\nor other liability obligations and/or rights consistent with this\nLicense. However, in accepting such obligations, You may act only\non Your own behalf and on Your sole responsibility, not on behalf\nof any other Contributor, and only if You agree to indemnify,\ndefend, and hold each Contributor harmless for any liability\nincurred by, or claims asserted against, such Contributor by reason\nof your accepting any such warranty or additional liability.    END OF TERMS AND CONDITIONS  APPENDIX: How to apply the Apache License to your work.  To apply the Apache License to your work, attach the following\nboilerplate notice, with the fields enclosed by brackets \"{}\"\nreplaced with your own identifying information. (Don't include\nthe brackets!)  The text should be enclosed in the appropriate\ncomment syntax for the file format. We also recommend that a\nfile or class name and description of purpose be included on the\nsame \"printed page\" as the copyright notice for easier\nidentification within third-party archives.  Copyright 2017 Kevin Wang  Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.", 
            "title": "License"
        }
    ]
}